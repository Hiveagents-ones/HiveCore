# -*- coding: utf-8 -*-
"""Scaffold executor for project initialization commands in sandbox.

This module provides safe execution of scaffold/initialization commands
in isolated Docker sandboxes. Commands are NOT hardcoded - instead, they
are dynamically generated by LLM based on user requirements.

Key design principles:
1. LLM decides what commands to run based on context
2. All commands execute in isolated sandbox for security
3. Command validation prevents dangerous operations
4. Execution results are tracked for feedback loop
"""
from __future__ import annotations

import re
import shlex
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, TYPE_CHECKING

from .._logging import logger

if TYPE_CHECKING:
    from .sandbox_orchestrator import SandboxOrchestrator
    from .task_executor import SandboxTaskExecutor, SandboxTask


class CommandCategory(str, Enum):
    """Category of commands for classification."""

    SCAFFOLD = "scaffold"  # Project scaffolding (init, create)
    DEPENDENCY = "dependency"  # Package installation
    BUILD = "build"  # Build and compile
    MIGRATION = "migration"  # Database migrations
    TEST = "test"  # Testing
    DEPLOY = "deploy"  # Deployment
    OTHER = "other"  # Uncategorized


class CommandRisk(str, Enum):
    """Risk level of commands."""

    LOW = "low"  # Safe commands (ls, echo, etc.)
    MEDIUM = "medium"  # Standard dev commands (npm install, pip install)
    HIGH = "high"  # Potentially dangerous (rm, chmod, etc.)
    BLOCKED = "blocked"  # Never allowed (rm -rf /, etc.)


@dataclass
class CommandValidationResult:
    """Result of command validation."""

    allowed: bool
    risk: CommandRisk
    reason: str = ""
    sanitized_command: str | None = None


@dataclass
class ScaffoldResult:
    """Result of a scaffold command execution."""

    success: bool
    command: str
    output: str = ""
    error: str | None = None
    exit_code: int = 0
    working_dir: str = ""
    duration_seconds: float = 0.0
    category: CommandCategory = CommandCategory.OTHER


@dataclass
class ScaffoldPlan:
    """Plan for executing multiple commands.

    Commands are strings decided by LLM, not predefined templates.
    """

    commands: list[str] = field(default_factory=list)
    working_dir: str = "/workspace"
    description: str = ""
    env_vars: dict[str, str] = field(default_factory=dict)

    def add(self, command: str) -> "ScaffoldPlan":
        """Add a command to the plan.

        Args:
            command: Shell command to execute.

        Returns:
            Self for chaining.
        """
        self.commands.append(command)
        return self


class CommandValidator:
    """Validates and sanitizes commands before execution.

    This class provides security checks to prevent dangerous commands
    from being executed, even in a sandbox environment.
    """

    # Patterns that are always blocked
    BLOCKED_PATTERNS: list[tuple[str, str]] = [
        (r"rm\s+-rf\s+/\s*$", "Removing root filesystem"),
        (r"rm\s+-rf\s+/\*", "Removing all files from root"),
        (r":\(\)\s*\{\s*:\|:\s*&\s*\}\s*;", "Fork bomb"),
        (r"mkfs\.", "Formatting filesystem"),
        (r"dd\s+if=.*of=/dev/", "Direct disk write"),
        (r">\s*/dev/sd[a-z]", "Direct disk write"),
        (r"chmod\s+-R\s+777\s+/\s*$", "Unsafe permissions on root"),
        (r"curl.*\|\s*(ba)?sh", "Pipe to shell (prefer explicit download)"),
        (r"wget.*\|\s*(ba)?sh", "Pipe to shell (prefer explicit download)"),
    ]

    # High-risk commands that need extra caution
    HIGH_RISK_COMMANDS: set[str] = {
        "rm", "rmdir", "chmod", "chown", "sudo",
        "kill", "pkill", "killall",
        "reboot", "shutdown", "halt",
        "mount", "umount",
        "iptables", "ufw",
    }

    # Commands that modify system state
    MEDIUM_RISK_COMMANDS: set[str] = {
        "pip", "npm", "yarn", "pnpm", "gem", "cargo", "go",
        "apt", "apt-get", "yum", "dnf", "brew", "pacman",
        "git", "docker", "docker-compose", "kubectl",
        "mv", "cp",
    }

    def __init__(
        self,
        *,
        allow_high_risk: bool = False,
        custom_blocked_patterns: list[tuple[str, str]] | None = None,
        custom_validators: list[Callable[[str], CommandValidationResult | None]] | None = None,
    ) -> None:
        """Initialize command validator.

        Args:
            allow_high_risk: Whether to allow high-risk commands.
            custom_blocked_patterns: Additional patterns to block.
            custom_validators: Custom validation functions.
        """
        self._allow_high_risk = allow_high_risk
        self._blocked_patterns = list(self.BLOCKED_PATTERNS)
        if custom_blocked_patterns:
            self._blocked_patterns.extend(custom_blocked_patterns)
        self._custom_validators = custom_validators or []

    def validate(self, command: str) -> CommandValidationResult:
        """Validate a command for safety.

        Args:
            command: Shell command to validate.

        Returns:
            CommandValidationResult with validation status.
        """
        command = command.strip()

        if not command:
            return CommandValidationResult(
                allowed=False,
                risk=CommandRisk.BLOCKED,
                reason="Empty command",
            )

        # Check blocked patterns
        for pattern, reason in self._blocked_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                return CommandValidationResult(
                    allowed=False,
                    risk=CommandRisk.BLOCKED,
                    reason=f"Blocked pattern: {reason}",
                )

        # Run custom validators
        for validator in self._custom_validators:
            result = validator(command)
            if result is not None and not result.allowed:
                return result

        # Extract base command
        try:
            parts = shlex.split(command)
            base_cmd = parts[0].split("/")[-1] if parts else ""
        except ValueError:
            # Shell parsing failed, still allow but flag as medium risk
            return CommandValidationResult(
                allowed=True,
                risk=CommandRisk.MEDIUM,
                reason="Complex shell syntax",
                sanitized_command=command,
            )

        # Check risk level
        if base_cmd in self.HIGH_RISK_COMMANDS:
            if not self._allow_high_risk:
                return CommandValidationResult(
                    allowed=False,
                    risk=CommandRisk.HIGH,
                    reason=f"High-risk command: {base_cmd}",
                )
            return CommandValidationResult(
                allowed=True,
                risk=CommandRisk.HIGH,
                reason=f"High-risk command allowed: {base_cmd}",
                sanitized_command=command,
            )

        if base_cmd in self.MEDIUM_RISK_COMMANDS:
            return CommandValidationResult(
                allowed=True,
                risk=CommandRisk.MEDIUM,
                reason=f"Standard development command: {base_cmd}",
                sanitized_command=command,
            )

        return CommandValidationResult(
            allowed=True,
            risk=CommandRisk.LOW,
            sanitized_command=command,
        )

    def classify_category(self, command: str) -> CommandCategory:
        """Classify a command into a category.

        Args:
            command: Shell command to classify.

        Returns:
            CommandCategory for the command.
        """
        command_lower = command.lower()

        # Test patterns (check early - "npm test" should be TEST not DEPENDENCY)
        test_patterns = [
            " test", "pytest", "jest", "mocha", "vitest",
            "cypress", "playwright", "run test",
        ]
        if any(p in command_lower for p in test_patterns):
            return CommandCategory.TEST

        # Deploy patterns (check before build - "docker build" should be DEPLOY)
        deploy_patterns = [
            "deploy", "publish", "release", "docker",
            "kubectl", "helm",
        ]
        if any(p in command_lower for p in deploy_patterns):
            return CommandCategory.DEPLOY

        # Build patterns (check before dependency - "npm run build" should be BUILD)
        build_patterns = [
            "run build", " build", "compile", "webpack",
            "vite build", "tsc", "babel", "rollup", "esbuild",
        ]
        # Special case: standalone "make" command
        if command_lower.strip() == "make" or command_lower.startswith("make "):
            return CommandCategory.BUILD
        if any(p in command_lower for p in build_patterns):
            return CommandCategory.BUILD

        # Migration patterns
        migration_patterns = [
            "migrate", "migration", "alembic", "prisma migrate",
            "sequelize", "typeorm",
        ]
        if any(p in command_lower for p in migration_patterns):
            return CommandCategory.MIGRATION

        # Scaffold patterns
        scaffold_patterns = [
            "create", "init", "new", "generate", "scaffold",
            "startproject", "startapp",
        ]
        if any(p in command_lower for p in scaffold_patterns):
            return CommandCategory.SCAFFOLD

        # Dependency patterns (check last - most general)
        dep_patterns = [
            "install", " add ", "update", "upgrade",
            "pip ", "npm ", "yarn ", "pnpm ", "cargo ", "go get",
            "requirements", "package.json",
        ]
        if any(p in command_lower for p in dep_patterns):
            return CommandCategory.DEPENDENCY

        return CommandCategory.OTHER


class ScaffoldExecutor:
    """Executor for scaffold commands in sandbox environment.

    This class executes shell commands in isolated Docker containers.
    Commands are NOT predefined - they are dynamically decided by LLM.

    The executor provides:
    1. Command validation for security
    2. Isolated execution in sandbox
    3. Result tracking and history
    4. Project type detection
    5. Task queue for long-running commands (optional)
    """

    def __init__(
        self,
        sandbox_orchestrator: "SandboxOrchestrator",
        *,
        default_working_dir: str = "/workspace",
        validator: CommandValidator | None = None,
        allow_high_risk: bool = False,
        use_task_queue: bool = True,
        auto_detect_long_commands: bool = True,
    ) -> None:
        """Initialize scaffold executor.

        Args:
            sandbox_orchestrator: Orchestrator for getting sandboxes.
            default_working_dir: Default working directory in sandbox.
            validator: Custom command validator.
            allow_high_risk: Whether to allow high-risk commands.
            use_task_queue: Whether to use task queue for long commands.
            auto_detect_long_commands: Auto-detect and use task queue for
                long-running commands (pip install, npm install, etc.)
        """
        self._orchestrator = sandbox_orchestrator
        self._default_working_dir = default_working_dir
        self._validator = validator or CommandValidator(allow_high_risk=allow_high_risk)
        self._execution_history: list[ScaffoldResult] = []
        self._use_task_queue = use_task_queue
        self._auto_detect_long_commands = auto_detect_long_commands

    @property
    def execution_history(self) -> list[ScaffoldResult]:
        """Get the execution history."""
        return self._execution_history.copy()

    @property
    def validator(self) -> CommandValidator:
        """Get the command validator."""
        return self._validator

    def _get_sandbox(self) -> Any:
        """Get a filesystem sandbox for execution."""
        from .sandbox_orchestrator import SandboxTypeEnum

        return self._orchestrator.get_sandbox(SandboxTypeEnum.FILESYSTEM)

    def execute(
        self,
        command: str,
        *,
        working_dir: str | None = None,
        env_vars: dict[str, str] | None = None,
        timeout: int = 300,
        skip_validation: bool = False,
        force_task_queue: bool = False,
        force_direct: bool = False,
    ) -> ScaffoldResult:
        """Execute a shell command in sandbox.

        This is the main method for executing LLM-generated commands.

        Args:
            command: Shell command to execute.
            working_dir: Working directory (default: /workspace).
            env_vars: Environment variables to set.
            timeout: Timeout in seconds.
            skip_validation: Skip command validation (use with caution).
            force_task_queue: Force use task queue for this command.
            force_direct: Force direct execution (bypass task queue).

        Returns:
            ScaffoldResult with execution details.
        """
        import time

        command = command.strip()
        work_dir = working_dir or self._default_working_dir

        # Validate command
        if not skip_validation:
            validation = self._validator.validate(command)
            if not validation.allowed:
                logger.warning(
                    "Command blocked: %s - %s",
                    command[:50],
                    validation.reason,
                )
                return ScaffoldResult(
                    success=False,
                    command=command,
                    error=f"Command blocked: {validation.reason}",
                    working_dir=work_dir,
                    category=self._validator.classify_category(command),
                )

        # Classify command
        category = self._validator.classify_category(command)

        # Determine execution mode
        use_task_queue = False
        if not force_direct:
            if force_task_queue:
                use_task_queue = True
            elif self._use_task_queue and self._auto_detect_long_commands:
                # Auto-detect long-running commands
                from .task_executor import is_long_running_command
                use_task_queue = is_long_running_command(command)

        if use_task_queue:
            return self._execute_via_task_queue(
                command,
                working_dir=work_dir,
                env_vars=env_vars,
                timeout=timeout,
                category=category,
            )

        # Direct execution mode
        return self._execute_direct(
            command,
            working_dir=work_dir,
            env_vars=env_vars,
            timeout=timeout,
            category=category,
        )

    def _execute_direct(
        self,
        command: str,
        *,
        working_dir: str,
        env_vars: dict[str, str] | None,
        timeout: int,
        category: CommandCategory,
    ) -> ScaffoldResult:
        """Execute command directly via sandbox.

        Args:
            command: Shell command to execute.
            working_dir: Working directory.
            env_vars: Environment variables.
            timeout: Timeout in seconds.
            category: Command category.

        Returns:
            ScaffoldResult with execution details.
        """
        import time

        # Build full command with cd and env vars
        env_prefix = ""
        if env_vars:
            env_parts = [f"{k}={shlex.quote(v)}" for k, v in env_vars.items()]
            env_prefix = " ".join(env_parts) + " "

        full_cmd = f"cd {shlex.quote(working_dir)} && {env_prefix}{command}"

        logger.info(
            "Executing command [%s]: %s",
            category.value,
            command[:100] + ("..." if len(command) > 100 else ""),
        )

        # Get sandbox and execute
        sandbox = self._get_sandbox()

        start_time = time.time()
        try:
            result = sandbox.run_shell_command(command=full_cmd, timeout=timeout)
            duration = time.time() - start_time

            # Parse result
            output = ""
            exit_code = 0

            if isinstance(result, dict):
                output = result.get("stdout", "") or result.get("output", "")
                exit_code = result.get("exit_code", 0) or result.get("returncode", 0)
                stderr = result.get("stderr", "")
                if stderr:
                    output = output + "\n[stderr]\n" + stderr if output else stderr

                # Handle MCP-style response
                content = result.get("content", [])
                if content and isinstance(content, list):
                    parts = []
                    for item in content:
                        if isinstance(item, dict) and item.get("type") == "text":
                            desc = item.get("description", "")
                            if desc == "returncode":
                                try:
                                    exit_code = int(item.get("text", "0"))
                                except ValueError:
                                    pass
                            elif desc == "stderr":
                                stderr_text = item.get("text", "")
                                if stderr_text:
                                    parts.append(f"[stderr]\n{stderr_text}")
                            else:
                                parts.append(item.get("text", ""))
                    if parts:
                        output = "\n".join(parts)

            elif isinstance(result, str):
                output = result
            else:
                output = str(result)

            success = exit_code == 0

            scaffold_result = ScaffoldResult(
                success=success,
                command=command,
                output=output,
                exit_code=exit_code,
                working_dir=working_dir,
                duration_seconds=duration,
                category=category,
            )

            logger.info(
                "Command %s (exit=%d, %.2fs): %s",
                "succeeded" if success else "failed",
                exit_code,
                duration,
                command[:50],
            )

        except Exception as exc:
            duration = time.time() - start_time
            scaffold_result = ScaffoldResult(
                success=False,
                command=command,
                error=str(exc),
                working_dir=working_dir,
                duration_seconds=duration,
                category=category,
            )
            logger.error("Command execution error: %s", exc)

        self._execution_history.append(scaffold_result)
        return scaffold_result

    def _execute_via_task_queue(
        self,
        command: str,
        *,
        working_dir: str,
        env_vars: dict[str, str] | None,
        timeout: int,
        category: CommandCategory,
    ) -> ScaffoldResult:
        """Execute command via task queue for long-running commands.

        This prevents blocking the uvicorn worker during long operations
        like pip install, npm install, etc.

        Args:
            command: Shell command to execute.
            working_dir: Working directory.
            env_vars: Environment variables.
            timeout: Timeout in seconds.
            category: Command category.

        Returns:
            ScaffoldResult with execution details.
        """
        from .task_executor import TaskStatus

        logger.info(
            "Executing long command via task queue [%s]: %s",
            category.value,
            command[:100] + ("..." if len(command) > 100 else ""),
        )

        try:
            # Submit task and wait
            task = self._orchestrator.execute_long_command(
                command,
                timeout=timeout,
                working_dir=working_dir,
                env_vars=env_vars,
            )

            # Convert task result to ScaffoldResult
            success = task.status == TaskStatus.SUCCESS
            error = task.error if not success else None

            scaffold_result = ScaffoldResult(
                success=success,
                command=command,
                output=task.output,
                error=error,
                exit_code=task.exit_code or (0 if success else 1),
                working_dir=working_dir,
                duration_seconds=task.duration or 0.0,
                category=category,
            )

            logger.info(
                "Long command %s (exit=%s, %.2fs): %s",
                "succeeded" if success else "failed",
                task.exit_code,
                task.duration or 0.0,
                command[:50],
            )

        except Exception as exc:
            scaffold_result = ScaffoldResult(
                success=False,
                command=command,
                error=str(exc),
                working_dir=working_dir,
                duration_seconds=0.0,
                category=category,
            )
            logger.error("Task queue execution error: %s", exc)

        self._execution_history.append(scaffold_result)
        return scaffold_result

    def execute_many(
        self,
        commands: list[str],
        *,
        working_dir: str | None = None,
        env_vars: dict[str, str] | None = None,
        timeout: int = 300,
        stop_on_error: bool = True,
    ) -> list[ScaffoldResult]:
        """Execute multiple commands sequentially.

        Args:
            commands: List of shell commands to execute.
            working_dir: Working directory.
            env_vars: Environment variables.
            timeout: Timeout per command.
            stop_on_error: Stop execution on first error.

        Returns:
            List of ScaffoldResult for each command.
        """
        results: list[ScaffoldResult] = []

        for command in commands:
            result = self.execute(
                command,
                working_dir=working_dir,
                env_vars=env_vars,
                timeout=timeout,
            )
            results.append(result)

            if not result.success and stop_on_error:
                logger.warning("Stopping execution due to error: %s", command[:50])
                break

        return results

    def execute_plan(
        self,
        plan: ScaffoldPlan,
        *,
        timeout: int = 300,
        stop_on_error: bool = True,
    ) -> list[ScaffoldResult]:
        """Execute a scaffold plan.

        Args:
            plan: ScaffoldPlan with commands to execute.
            timeout: Timeout per command.
            stop_on_error: Stop on first error.

        Returns:
            List of ScaffoldResult for each command.
        """
        return self.execute_many(
            plan.commands,
            working_dir=plan.working_dir,
            env_vars=plan.env_vars,
            timeout=timeout,
            stop_on_error=stop_on_error,
        )

    def detect_project(
        self,
        working_dir: str | None = None,
    ) -> dict[str, Any]:
        """Detect project type from files in working directory.

        This helps LLM understand the project context.

        Args:
            working_dir: Directory to analyze.

        Returns:
            Dict with detected project info.
        """
        work_dir = working_dir or self._default_working_dir
        sandbox = self._get_sandbox()

        detection: dict[str, Any] = {
            "detected": False,
            "languages": [],
            "frameworks": [],
            "package_managers": [],
            "has_git": False,
            "has_docker": False,
            "files": [],
        }

        # List files in directory
        try:
            result = sandbox.run_shell_command(
                command=f"ls -la {shlex.quote(work_dir)} 2>/dev/null",
                timeout=30,
            )
            if isinstance(result, dict):
                output = result.get("stdout", "")
            else:
                output = str(result)
            detection["files"] = [
                line.split()[-1]
                for line in output.strip().split("\n")
                if line and not line.startswith("total")
            ]
        except Exception:
            pass

        files = set(detection["files"])

        # Detect by presence of files
        file_indicators = {
            # Python
            "requirements.txt": ("python", "pip"),
            "pyproject.toml": ("python", "poetry/pip"),
            "Pipfile": ("python", "pipenv"),
            "setup.py": ("python", "setuptools"),
            "manage.py": ("python", "django"),
            # Node.js
            "package.json": ("javascript", "npm"),
            "yarn.lock": ("javascript", "yarn"),
            "pnpm-lock.yaml": ("javascript", "pnpm"),
            "bun.lockb": ("javascript", "bun"),
            # Other languages
            "go.mod": ("go", "go"),
            "Cargo.toml": ("rust", "cargo"),
            "pom.xml": ("java", "maven"),
            "build.gradle": ("java", "gradle"),
            "composer.json": ("php", "composer"),
            "Gemfile": ("ruby", "bundler"),
            # Config
            ".git": (None, None),
            "Dockerfile": (None, None),
            "docker-compose.yml": (None, None),
            "docker-compose.yaml": (None, None),
        }

        for filename, (lang, pkg_mgr) in file_indicators.items():
            if filename in files:
                detection["detected"] = True
                if lang and lang not in detection["languages"]:
                    detection["languages"].append(lang)
                if pkg_mgr and pkg_mgr not in detection["package_managers"]:
                    detection["package_managers"].append(pkg_mgr)
                if filename == ".git":
                    detection["has_git"] = True
                if filename in ("Dockerfile", "docker-compose.yml", "docker-compose.yaml"):
                    detection["has_docker"] = True

        # Try to detect frameworks from package.json
        if "package.json" in files:
            try:
                result = sandbox.run_shell_command(
                    command=f"cat {shlex.quote(work_dir)}/package.json 2>/dev/null",
                    timeout=10,
                )
                import json

                if isinstance(result, dict):
                    content = result.get("stdout", "")
                else:
                    content = str(result)

                if content:
                    pkg = json.loads(content)
                    deps = {
                        **pkg.get("dependencies", {}),
                        **pkg.get("devDependencies", {}),
                    }
                    frameworks_map = {
                        "react": "react",
                        "vue": "vue",
                        "next": "nextjs",
                        "nuxt": "nuxt",
                        "svelte": "svelte",
                        "express": "express",
                        "fastify": "fastify",
                        "nest": "nestjs",
                        "angular": "angular",
                    }
                    for dep, fw in frameworks_map.items():
                        if any(dep in d for d in deps):
                            if fw not in detection["frameworks"]:
                                detection["frameworks"].append(fw)
            except Exception:
                pass

        # Try to detect Python frameworks
        if "python" in detection["languages"]:
            try:
                result = sandbox.run_shell_command(
                    command=f"cat {shlex.quote(work_dir)}/requirements.txt {shlex.quote(work_dir)}/pyproject.toml 2>/dev/null | head -100",
                    timeout=10,
                )
                if isinstance(result, dict):
                    content = result.get("stdout", "").lower()
                else:
                    content = str(result).lower()

                py_frameworks = {
                    "django": "django",
                    "fastapi": "fastapi",
                    "flask": "flask",
                    "tornado": "tornado",
                    "aiohttp": "aiohttp",
                    "pytorch": "pytorch",
                    "torch": "pytorch",
                    "tensorflow": "tensorflow",
                    "pandas": "pandas",
                }
                for pkg, fw in py_frameworks.items():
                    if pkg in content and fw not in detection["frameworks"]:
                        detection["frameworks"].append(fw)
            except Exception:
                pass

        return detection

    def get_context_for_llm(
        self,
        working_dir: str | None = None,
    ) -> str:
        """Get project context formatted for LLM.

        This provides context to help LLM decide what commands to run.

        Args:
            working_dir: Directory to analyze.

        Returns:
            Formatted string with project context.
        """
        detection = self.detect_project(working_dir)

        lines = ["## Project Context"]

        if not detection["detected"]:
            lines.append("- Empty directory or no recognizable project structure")
            return "\n".join(lines)

        if detection["languages"]:
            lines.append(f"- Languages: {', '.join(detection['languages'])}")

        if detection["frameworks"]:
            lines.append(f"- Frameworks: {', '.join(detection['frameworks'])}")

        if detection["package_managers"]:
            lines.append(f"- Package managers: {', '.join(detection['package_managers'])}")

        if detection["has_git"]:
            lines.append("- Git repository: Yes")

        if detection["has_docker"]:
            lines.append("- Docker: Yes")

        if detection["files"]:
            key_files = [f for f in detection["files"] if not f.startswith(".")][:10]
            if key_files:
                lines.append(f"- Key files: {', '.join(key_files)}")

        # Add recent execution history
        recent = self._execution_history[-5:] if self._execution_history else []
        if recent:
            lines.append("\n## Recent Commands")
            for r in recent:
                status = "✓" if r.success else "✗"
                lines.append(f"- [{status}] {r.command[:60]}")

        return "\n".join(lines)

    def clear_history(self) -> None:
        """Clear execution history."""
        self._execution_history.clear()
