# -*- coding: utf-8 -*-
"""Project scaffolding and finalization utilities.

This module provides:
- Project base file generation (requirements.txt, __init__.py, App.vue, etc.)
- Project file merging and deduplication
- Project completeness validation
- Project memory initialization for multi-agent consistency
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Any

from agentscope.ones.memory import DecisionCategory, ProjectMemory


# ---------------------------------------------------------------------------
# Project Base File Templates
# ---------------------------------------------------------------------------

BACKEND_REQUIREMENTS = """# Auto-generated requirements.txt
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
sqlalchemy>=2.0.0
pydantic>=2.5.0
python-multipart>=0.0.6
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
alembic>=1.13.0
psycopg2-binary>=2.9.9
celery[redis]>=5.3.0
"""

BACKEND_PYPROJECT_TOML = '''[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "backend"
version = "0.1.0"
description = "Backend API service"
requires-python = ">=3.10"
dependencies = [
    "fastapi>=0.109.0",
    "uvicorn[standard]>=0.27.0",
    "sqlalchemy>=2.0.0",
    "pydantic>=2.5.0",
    "python-multipart>=0.0.6",
    "python-jose[cryptography]>=3.3.0",
    "passlib[bcrypt]>=1.7.4",
    "alembic>=1.13.0",
    "psycopg2-binary>=2.9.9",
]

[tool.setuptools.packages.find]
where = ["."]
include = ["app*"]
'''

BACKEND_INIT_APP = '''# -*- coding: utf-8 -*-
"""App package initialization."""
'''

BACKEND_INIT_ROUTERS = '''# -*- coding: utf-8 -*-
"""Routers package initialization.

Import routers here as they are created by agents.
Example:
    from .auth import router as auth_router
    __all__ = ["auth_router"]
"""
# Routers will be imported as they are generated by agents
'''

BACKEND_INIT_MODELS = '''# -*- coding: utf-8 -*-
"""Models package initialization."""
'''

BACKEND_INIT_SCHEMAS = '''# -*- coding: utf-8 -*-
"""Schemas package initialization."""
'''

BACKEND_INIT_CRUD = '''# -*- coding: utf-8 -*-
"""CRUD package initialization."""
'''

FRONTEND_APP_VUE = '''<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script setup lang="ts">
// Main App component
</script>

<style>
#app {
  font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB',
    'Microsoft YaHei', Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
</style>
'''

FRONTEND_MAIN_TS = '''import { createApp } from 'vue'
import { createPinia } from 'pinia'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())
app.use(router)
app.use(ElementPlus)

app.mount('#app')
'''

FRONTEND_ROUTER_INDEX = '''import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

// Routes will be added by agents based on project requirements
const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/HomeView.vue'),
  },
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

export default router
'''

FRONTEND_VITE_CONFIG = '''import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
    },
  },
})
'''

FRONTEND_TSCONFIG = '''{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
'''

FRONTEND_TSCONFIG_NODE = '''{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
'''

FRONTEND_ENV_D_TS = '''/// <reference types="vite/client" />

declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}
'''

FRONTEND_HOME_VIEW = '''<template>
  <div class="home-view">
    <h1>Welcome</h1>
    <p>This is the home page. Content will be generated by agents.</p>
  </div>
</template>

<script setup lang="ts">
// Component logic will be added by agents
</script>

<style scoped>
.home-view {
  padding: 40px;
  text-align: center;
}
</style>
'''

FRONTEND_UTILS_AUTH = '''const TOKEN_KEY = 'app_auth_token'

export function getToken(): string | null {
  return localStorage.getItem(TOKEN_KEY)
}

export function setToken(token: string): void {
  localStorage.setItem(TOKEN_KEY, token)
}

export function removeToken(): void {
  localStorage.removeItem(TOKEN_KEY)
}
'''

DOCKER_COMPOSE = '''version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/membership_db
    depends_on:
      - db

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend

  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=membership_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
'''

BACKEND_DOCKERFILE = '''FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''

FRONTEND_DOCKERFILE = '''FROM node:20-alpine AS build

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
'''

FRONTEND_NGINX_CONF = '''server {
    listen 3000;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
'''

FRONTEND_PACKAGE_JSON = '''{
  "name": "frontend",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix"
  },
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.5",
    "pinia": "^2.1.7",
    "element-plus": "^2.4.4",
    "@element-plus/icons-vue": "^2.3.1",
    "axios": "^1.6.2"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "typescript": "~5.6.0",
    "vite": "^5.4.0",
    "vue-tsc": "^2.0.0",
    "@types/node": "^20.10.5",
    "sass": "^1.69.5"
  }
}
'''

FRONTEND_INDEX_HTML = '''<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
'''


# ---------------------------------------------------------------------------
# Scaffolding Functions
# ---------------------------------------------------------------------------

def generate_project_scaffolding(
    workspace_dir: Path,
    project_type: str = "fullstack",
    runtime_workspace: "Any | None" = None,
) -> list[str]:
    """Generate project base files.

    Args:
        workspace_dir: Target workspace directory
        project_type: Type of project (fullstack, frontend, backend)
        runtime_workspace: RuntimeWorkspace for syncing files to container

    Returns:
        list: List of generated file paths
    """
    generated_files: list[str] = []

    def _write_and_sync(file_path: Path, rel_path: str, content: str) -> None:
        """Write file to host and sync to container if runtime_workspace is available."""
        if not file_path.exists():
            file_path.write_text(content, encoding="utf-8")
            generated_files.append(rel_path)
            # Sync to container
            if runtime_workspace:
                try:
                    runtime_workspace.write_file(rel_path, content)
                except Exception:
                    pass  # Ignore container sync errors for scaffolding

    if project_type in ("fullstack", "backend"):
        # Backend files
        backend_dir = workspace_dir / "backend"
        backend_dir.mkdir(parents=True, exist_ok=True)

        # requirements.txt
        req_file = backend_dir / "requirements.txt"
        _write_and_sync(req_file, "backend/requirements.txt", BACKEND_REQUIREMENTS)

        # Dockerfile
        dockerfile = backend_dir / "Dockerfile"
        _write_and_sync(dockerfile, "backend/Dockerfile", BACKEND_DOCKERFILE)

        # pyproject.toml (for pip install -e . support)
        pyproject_file = backend_dir / "pyproject.toml"
        _write_and_sync(pyproject_file, "backend/pyproject.toml", BACKEND_PYPROJECT_TOML)

        # app/__init__.py
        app_dir = backend_dir / "app"
        app_dir.mkdir(parents=True, exist_ok=True)
        init_file = app_dir / "__init__.py"
        _write_and_sync(init_file, "backend/app/__init__.py", BACKEND_INIT_APP)

        # routers/__init__.py
        routers_dir = app_dir / "routers"
        routers_dir.mkdir(parents=True, exist_ok=True)
        routers_init = routers_dir / "__init__.py"
        _write_and_sync(routers_init, "backend/app/routers/__init__.py", BACKEND_INIT_ROUTERS)

        # models/__init__.py
        models_dir = app_dir / "models"
        models_dir.mkdir(parents=True, exist_ok=True)
        models_init = models_dir / "__init__.py"
        _write_and_sync(models_init, "backend/app/models/__init__.py", BACKEND_INIT_MODELS)

        # schemas/__init__.py
        schemas_dir = app_dir / "schemas"
        schemas_dir.mkdir(parents=True, exist_ok=True)
        schemas_init = schemas_dir / "__init__.py"
        _write_and_sync(schemas_init, "backend/app/schemas/__init__.py", BACKEND_INIT_SCHEMAS)

        # crud/__init__.py
        crud_dir = app_dir / "crud"
        crud_dir.mkdir(parents=True, exist_ok=True)
        crud_init = crud_dir / "__init__.py"
        _write_and_sync(crud_init, "backend/app/crud/__init__.py", BACKEND_INIT_CRUD)

    if project_type in ("fullstack", "frontend"):
        # Frontend files
        frontend_dir = workspace_dir / "frontend"
        frontend_dir.mkdir(parents=True, exist_ok=True)

        src_dir = frontend_dir / "src"
        src_dir.mkdir(parents=True, exist_ok=True)

        # App.vue
        app_vue = src_dir / "App.vue"
        _write_and_sync(app_vue, "frontend/src/App.vue", FRONTEND_APP_VUE)

        # main.ts
        main_ts = src_dir / "main.ts"
        _write_and_sync(main_ts, "frontend/src/main.ts", FRONTEND_MAIN_TS)

        # router/index.ts
        router_dir = src_dir / "router"
        router_dir.mkdir(parents=True, exist_ok=True)
        router_index = router_dir / "index.ts"
        _write_and_sync(router_index, "frontend/src/router/index.ts", FRONTEND_ROUTER_INDEX)

        # vite.config.ts
        vite_config = frontend_dir / "vite.config.ts"
        _write_and_sync(vite_config, "frontend/vite.config.ts", FRONTEND_VITE_CONFIG)

        # tsconfig.json
        tsconfig = frontend_dir / "tsconfig.json"
        _write_and_sync(tsconfig, "frontend/tsconfig.json", FRONTEND_TSCONFIG)

        # tsconfig.node.json
        tsconfig_node = frontend_dir / "tsconfig.node.json"
        _write_and_sync(tsconfig_node, "frontend/tsconfig.node.json", FRONTEND_TSCONFIG_NODE)

        # env.d.ts
        env_dts = src_dir / "env.d.ts"
        _write_and_sync(env_dts, "frontend/src/env.d.ts", FRONTEND_ENV_D_TS)

        # views/HomeView.vue
        views_dir = src_dir / "views"
        views_dir.mkdir(parents=True, exist_ok=True)
        home_view = views_dir / "HomeView.vue"
        _write_and_sync(home_view, "frontend/src/views/HomeView.vue", FRONTEND_HOME_VIEW)

        # utils/auth.ts
        utils_dir = src_dir / "utils"
        utils_dir.mkdir(parents=True, exist_ok=True)
        auth_ts = utils_dir / "auth.ts"
        _write_and_sync(auth_ts, "frontend/src/utils/auth.ts", FRONTEND_UTILS_AUTH)

        # Dockerfile
        dockerfile = frontend_dir / "Dockerfile"
        _write_and_sync(dockerfile, "frontend/Dockerfile", FRONTEND_DOCKERFILE)

        # nginx.conf
        nginx_conf = frontend_dir / "nginx.conf"
        _write_and_sync(nginx_conf, "frontend/nginx.conf", FRONTEND_NGINX_CONF)

        # package.json
        package_json = frontend_dir / "package.json"
        _write_and_sync(package_json, "frontend/package.json", FRONTEND_PACKAGE_JSON)

        # index.html
        index_html = frontend_dir / "index.html"
        _write_and_sync(index_html, "frontend/index.html", FRONTEND_INDEX_HTML)

    if project_type == "fullstack":
        # Docker Compose
        docker_compose = workspace_dir / "docker-compose.yml"
        _write_and_sync(docker_compose, "docker-compose.yml", DOCKER_COMPOSE)

    # Initialize project memory with base technology decisions
    initialize_project_memory(workspace_dir, project_type)

    return generated_files


def initialize_project_memory(
    workspace_dir: Path,
    project_type: str = "fullstack",
    project_id: str = "default",
) -> ProjectMemory:
    """Initialize an empty project memory for agents to populate.

    This function creates an empty project memory file. Agents will record
    their own technology decisions and other important information during
    execution. The memory ensures consistency across multiple rounds.

    Args:
        workspace_dir: Target workspace directory.
        project_type: Type of project (fullstack, frontend, backend).
        project_id: Unique project identifier.

    Returns:
        ProjectMemory: Empty project memory instance ready for agents to use.
    """
    memory = ProjectMemory(project_id=project_id, workspace_dir=workspace_dir)

    # Clear existing memory for fresh start
    memory.clear()

    # Only record the project type as a basic constraint
    # All technology decisions will be made by agents
    memory.record_decision(
        category=DecisionCategory.CONSTRAINT,
        key="project_type",
        value=project_type,
        description=f"项目类型: {project_type}",
        made_by="scaffold",
        round_index=0,
    )

    return memory


def finalize_project(
    workspace_dir: Path,
    deliverables_dir: Path,
) -> dict[str, Any]:
    """Finalize project by merging files and validating completeness.

    Args:
        workspace_dir: Workspace directory with generated code
        deliverables_dir: Directory containing project JSON files

    Returns:
        dict: Finalization report with merged files and validation results
    """
    report: dict[str, Any] = {
        "merged_files": [],
        "copied_files": [],
        "conflicts": [],
        "file_errors": [],  # Collect file operation errors for LLM analysis
        "validation": {"passed": True, "missing": [], "errors": []},
    }

    # Collect all files from project JSONs
    all_files: dict[str, list[dict[str, Any]]] = {}
    project_files = list(deliverables_dir.glob("REQ-*_project.json"))

    for pf in project_files:
        try:
            with open(pf, encoding="utf-8") as f:
                data = json.load(f)
            for file_info in data.get("files", []):
                path = file_info.get("path", "")
                content = file_info.get("content", "")
                if path and content:
                    if path not in all_files:
                        all_files[path] = []
                    all_files[path].append({
                        "source": pf.name,
                        "content": content,
                    })
        except Exception as e:
            report["validation"]["errors"].append(f"Failed to parse {pf.name}: {e}")

    # Process files - copy or merge
    for file_path, versions in all_files.items():
        full_path = workspace_dir / file_path

        try:
            # Check if path is a directory (conflict)
            if full_path.exists() and full_path.is_dir():
                report["file_errors"].append({
                    "path": file_path,
                    "error": "Path exists as directory",
                    "type": "is_directory",
                    "suggestion": "Skip or rename file",
                })
                continue

            full_path.parent.mkdir(parents=True, exist_ok=True)

            if len(versions) == 1:
                # Single version - just copy
                full_path.write_text(versions[0]["content"], encoding="utf-8")
                report["copied_files"].append(file_path)
            else:
                # Multiple versions - need to merge or pick best
                # For now, use the longest version (most complete)
                best_version = max(versions, key=lambda v: len(v["content"]))
                full_path.write_text(best_version["content"], encoding="utf-8")
                report["merged_files"].append({
                    "path": file_path,
                    "sources": [v["source"] for v in versions],
                    "selected": best_version["source"],
                })
                report["conflicts"].append({
                    "path": file_path,
                    "versions": len(versions),
                })

        except IsADirectoryError:
            report["file_errors"].append({
                "path": file_path,
                "error": "Cannot write to directory path",
                "type": "is_directory",
                "suggestion": "Skip or rename file",
            })
        except PermissionError as e:
            report["file_errors"].append({
                "path": file_path,
                "error": f"Permission denied: {e}",
                "type": "permission",
                "suggestion": "Check file permissions",
            })
        except Exception as e:
            report["file_errors"].append({
                "path": file_path,
                "error": str(e),
                "type": "unknown",
                "suggestion": "Review error and retry",
            })

    # Fix frontend import issues
    fix_report = fix_frontend_imports(workspace_dir)
    report["import_fixes"] = fix_report

    # Validate project completeness
    validation = validate_project_completeness(workspace_dir)
    report["validation"].update(validation)

    return report


def fix_frontend_imports(workspace_dir: Path) -> dict[str, Any]:
    """Fix common import issues in frontend code.

    This function scans Vue/TS/JS files and fixes:
    - Removes imports of incompatible libraries (vuex, vuetify)
    - Fixes import paths to match actual file structure
    - Updates package.json with missing dependencies

    Args:
        workspace_dir: Workspace directory to fix

    Returns:
        dict: Report of fixes made
    """
    import re

    report: dict[str, Any] = {
        "files_fixed": [],
        "imports_removed": [],
        "dependencies_added": [],
    }

    frontend_src = workspace_dir / "frontend/src"
    if not frontend_src.exists():
        return report

    # Patterns to remove (incompatible with Element Plus + Pinia stack)
    incompatible_imports = [
        (r"import\s+.*\s+from\s+['\"]vuex['\"].*\n?", "vuex"),
        (r"import\s+.*\s+from\s+['\"]vuetify['\"].*\n?", "vuetify"),
        (r"import\s+\{[^}]*useDisplay[^}]*\}\s+from\s+['\"]vuetify['\"].*\n?", "vuetify"),
        (r"import\s+\{[^}]*useStore[^}]*\}\s+from\s+['\"]vuex['\"].*\n?", "vuex"),
    ]

    # Scan and fix files
    for ext in ["*.vue", "*.ts", "*.js"]:
        for file_path in frontend_src.rglob(ext):
            try:
                content = file_path.read_text(encoding="utf-8")
                original_content = content
                file_fixed = False

                for pattern, lib_name in incompatible_imports:
                    if re.search(pattern, content):
                        content = re.sub(pattern, "", content)
                        report["imports_removed"].append({
                            "file": str(file_path.relative_to(workspace_dir)),
                            "library": lib_name,
                        })
                        file_fixed = True

                # Remove unused variables from removed imports
                # e.g., "const { mobile } = useDisplay()" when useDisplay is removed
                unused_patterns = [
                    r"const\s+\{[^}]*\}\s*=\s*useDisplay\(\)\s*\n?",
                    r"const\s+\w+\s*=\s*useStore\(\)\s*\n?",
                ]
                for pattern in unused_patterns:
                    if re.search(pattern, content):
                        content = re.sub(pattern, "", content)
                        file_fixed = True

                if file_fixed and content != original_content:
                    file_path.write_text(content, encoding="utf-8")
                    report["files_fixed"].append(
                        str(file_path.relative_to(workspace_dir))
                    )

            except Exception:
                pass  # Skip files that can't be processed

    # Ensure package.json has required dependencies
    package_json_path = workspace_dir / "frontend/package.json"
    if package_json_path.exists():
        try:
            package_data = json.loads(package_json_path.read_text(encoding="utf-8"))
            deps = package_data.get("dependencies", {})

            required_deps = {
                "chart.js": "^4.4.0",
                "@vueuse/core": "^10.7.0",
            }

            for dep, version in required_deps.items():
                if dep not in deps:
                    deps[dep] = version
                    report["dependencies_added"].append(dep)

            if report["dependencies_added"]:
                package_data["dependencies"] = deps
                package_json_path.write_text(
                    json.dumps(package_data, indent=2, ensure_ascii=False),
                    encoding="utf-8",
                )

        except Exception:
            pass

    return report


def validate_project_completeness(workspace_dir: Path) -> dict[str, Any]:
    """Validate that project has all required files.

    Args:
        workspace_dir: Workspace directory to validate

    Returns:
        dict: Validation results
    """
    result: dict[str, Any] = {
        "passed": True,
        "missing": [],
        "warnings": [],
    }

    # Required backend files
    backend_required = [
        "backend/requirements.txt",
        "backend/app/__init__.py",
        "backend/app/main.py",
        "backend/app/database.py",
    ]

    # Required frontend files
    frontend_required = [
        "frontend/package.json",
        "frontend/index.html",
        "frontend/src/App.vue",
        "frontend/src/main.ts",
        "frontend/vite.config.ts",
    ]

    # Check backend
    for req_file in backend_required:
        if not (workspace_dir / req_file).exists():
            result["missing"].append(req_file)
            result["passed"] = False

    # Check frontend
    for req_file in frontend_required:
        if not (workspace_dir / req_file).exists():
            result["missing"].append(req_file)
            result["passed"] = False

    # Check for common issues
    # 1. Check if router has routes
    router_files = list((workspace_dir / "frontend/src/router").glob("*.ts")) + \
                   list((workspace_dir / "frontend/src/router").glob("*.js"))
    if not router_files:
        result["warnings"].append("No router configuration found")

    # 2. Check if there are any views
    views_dir = workspace_dir / "frontend/src/views"
    if views_dir.exists():
        vue_files = list(views_dir.glob("*.vue"))
        if len(vue_files) < 2:
            result["warnings"].append(f"Only {len(vue_files)} view components found")

    return result


# ---------------------------------------------------------------------------
# Scaffold Files Plan (for Blueprint integration)
# ---------------------------------------------------------------------------

# Base scaffold files with their content templates
SCAFFOLD_FILES_TEMPLATES: dict[str, tuple[str, str]] = {
    # Backend files
    "backend/requirements.txt": (BACKEND_REQUIREMENTS, "Python 依赖配置"),
    "backend/pyproject.toml": (BACKEND_PYPROJECT_TOML, "Python 项目配置"),
    "backend/app/__init__.py": (BACKEND_INIT_APP, "后端 app 包初始化"),
    "backend/app/routers/__init__.py": (BACKEND_INIT_ROUTERS, "路由包初始化"),
    "backend/app/models/__init__.py": (BACKEND_INIT_MODELS, "模型包初始化"),
    "backend/app/schemas/__init__.py": (BACKEND_INIT_SCHEMAS, "Schema 包初始化"),
    "backend/app/crud/__init__.py": (BACKEND_INIT_CRUD, "CRUD 包初始化"),
    "backend/Dockerfile": (BACKEND_DOCKERFILE, "后端 Docker 配置"),
    # Frontend files
    "frontend/package.json": (FRONTEND_PACKAGE_JSON, "前端依赖配置"),
    "frontend/index.html": (FRONTEND_INDEX_HTML, "前端入口 HTML"),
    "frontend/vite.config.ts": (FRONTEND_VITE_CONFIG, "Vite 构建配置"),
    "frontend/tsconfig.json": (FRONTEND_TSCONFIG, "TypeScript 配置"),
    "frontend/tsconfig.node.json": (FRONTEND_TSCONFIG_NODE, "TypeScript Node 配置"),
    "frontend/src/App.vue": (FRONTEND_APP_VUE, "Vue 根组件"),
    "frontend/src/main.ts": (FRONTEND_MAIN_TS, "前端入口文件"),
    "frontend/src/router/index.ts": (FRONTEND_ROUTER_INDEX, "Vue Router 配置"),
    "frontend/src/env.d.ts": (FRONTEND_ENV_D_TS, "TypeScript 环境声明"),
    "frontend/src/views/HomeView.vue": (FRONTEND_HOME_VIEW, "首页视图"),
    "frontend/src/utils/auth.ts": (FRONTEND_UTILS_AUTH, "认证工具函数"),
    "frontend/Dockerfile": (FRONTEND_DOCKERFILE, "前端 Docker 配置"),
    "frontend/nginx.conf": (FRONTEND_NGINX_CONF, "Nginx 配置"),
    # Root files
    "docker-compose.yml": (DOCKER_COMPOSE, "Docker Compose 配置"),
}


def get_scaffold_files_plan(
    project_type: str = "fullstack",
    existing_files: list[str] | None = None,
) -> list[dict[str, Any]]:
    """Get scaffold files as files_plan format for Blueprint.

    This function returns the base scaffold files that should be created
    by Claude Code in the container. Only returns files that don't already exist.

    Args:
        project_type: Type of project (fullstack, frontend, backend)
        existing_files: List of files that already exist in workspace

    Returns:
        list: files_plan format list of scaffold files to create
    """
    existing = set(existing_files or [])
    files_plan: list[dict[str, Any]] = []

    for path, (content, description) in SCAFFOLD_FILES_TEMPLATES.items():
        # Skip if file already exists
        if path in existing:
            continue

        # Filter by project type
        if project_type == "frontend" and path.startswith("backend/"):
            continue
        if project_type == "backend" and path.startswith("frontend/"):
            continue

        files_plan.append({
            "path": path,
            "description": f"[基础文件] {description}",
            "action": "create",
            "priority": 0,  # Highest priority - create first
            "criteria_ids": [],  # No specific criteria
            "is_scaffold": True,  # Mark as scaffold file
            "content_template": content,  # Include template content
        })

    return files_plan


def get_scaffold_file_content(path: str) -> str | None:
    """Get the template content for a scaffold file.

    Args:
        path: File path (e.g., 'backend/requirements.txt')

    Returns:
        str | None: Template content or None if not a scaffold file
    """
    template = SCAFFOLD_FILES_TEMPLATES.get(path)
    return template[0] if template else None


__all__ = [
    "generate_project_scaffolding",
    "finalize_project",
    "validate_project_completeness",
    "initialize_project_memory",
    "get_scaffold_files_plan",
    "get_scaffold_file_content",
    "SCAFFOLD_FILES_TEMPLATES",
]
