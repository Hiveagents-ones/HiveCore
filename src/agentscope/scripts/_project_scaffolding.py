# -*- coding: utf-8 -*-
"""Project scaffolding and finalization utilities.

This module provides:
- Project base file generation (requirements.txt, __init__.py, App.vue, etc.)
- Project file merging and deduplication
- Project completeness validation
- Project memory initialization for multi-agent consistency
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Any

from agentscope.ones.memory import DecisionCategory, ProjectMemory


# ---------------------------------------------------------------------------
# Project Base File Templates
# ---------------------------------------------------------------------------

BACKEND_REQUIREMENTS = """# Auto-generated requirements.txt
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
sqlalchemy>=2.0.0
pydantic>=2.5.0
python-multipart>=0.0.6
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
alembic>=1.13.0
psycopg2-binary>=2.9.9
celery[redis]>=5.3.0
"""

BACKEND_INIT_APP = '''# -*- coding: utf-8 -*-
"""App package initialization."""
'''

BACKEND_INIT_ROUTERS = '''# -*- coding: utf-8 -*-
"""Routers package initialization.

Import routers here as they are created by agents.
Example:
    from .auth import router as auth_router
    __all__ = ["auth_router"]
"""
# Routers will be imported as they are generated by agents
'''

BACKEND_INIT_MODELS = '''# -*- coding: utf-8 -*-
"""Models package initialization."""
'''

BACKEND_INIT_SCHEMAS = '''# -*- coding: utf-8 -*-
"""Schemas package initialization."""
'''

BACKEND_INIT_CRUD = '''# -*- coding: utf-8 -*-
"""CRUD package initialization."""
'''

FRONTEND_APP_VUE = '''<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script setup lang="ts">
// Main App component
</script>

<style>
#app {
  font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB',
    'Microsoft YaHei', Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
</style>
'''

FRONTEND_MAIN_TS = '''import { createApp } from 'vue'
import { createPinia } from 'pinia'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())
app.use(router)
app.use(ElementPlus)

app.mount('#app')
'''

FRONTEND_ROUTER_INDEX = '''import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

// Routes will be added by agents based on project requirements
const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/HomeView.vue'),
  },
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

export default router
'''

FRONTEND_VITE_CONFIG = '''import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
    },
  },
})
'''

FRONTEND_TSCONFIG = '''{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
'''

FRONTEND_TSCONFIG_NODE = '''{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
'''

FRONTEND_ENV_D_TS = '''/// <reference types="vite/client" />

declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}
'''

FRONTEND_HOME_VIEW = '''<template>
  <div class="home-view">
    <h1>Welcome</h1>
    <p>This is the home page. Content will be generated by agents.</p>
  </div>
</template>

<script setup lang="ts">
// Component logic will be added by agents
</script>

<style scoped>
.home-view {
  padding: 40px;
  text-align: center;
}
</style>
'''

FRONTEND_UTILS_AUTH = '''const TOKEN_KEY = 'app_auth_token'

export function getToken(): string | null {
  return localStorage.getItem(TOKEN_KEY)
}

export function setToken(token: string): void {
  localStorage.setItem(TOKEN_KEY, token)
}

export function removeToken(): void {
  localStorage.removeItem(TOKEN_KEY)
}
'''

DOCKER_COMPOSE = '''version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/membership_db
    depends_on:
      - db

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend

  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=membership_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
'''

BACKEND_DOCKERFILE = '''FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''

FRONTEND_DOCKERFILE = '''FROM node:20-alpine AS build

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
'''

FRONTEND_NGINX_CONF = '''server {
    listen 3000;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
'''

FRONTEND_PACKAGE_JSON = '''{
  "name": "frontend",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix"
  },
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.5",
    "pinia": "^2.1.7",
    "element-plus": "^2.4.4",
    "@element-plus/icons-vue": "^2.3.1",
    "axios": "^1.6.2"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "typescript": "~5.6.0",
    "vite": "^5.4.0",
    "vue-tsc": "^2.0.0",
    "@types/node": "^20.10.5",
    "sass": "^1.69.5"
  }
}
'''

FRONTEND_INDEX_HTML = '''<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
'''


# ---------------------------------------------------------------------------
# Scaffolding Functions
# ---------------------------------------------------------------------------

def generate_project_scaffolding(
    workspace_dir: Path,
    project_type: str = "fullstack",
) -> list[str]:
    """Generate project base files.

    Args:
        workspace_dir: Target workspace directory
        project_type: Type of project (fullstack, frontend, backend)

    Returns:
        list: List of generated file paths
    """
    generated_files: list[str] = []

    if project_type in ("fullstack", "backend"):
        # Backend files
        backend_dir = workspace_dir / "backend"
        backend_dir.mkdir(parents=True, exist_ok=True)

        # requirements.txt
        req_file = backend_dir / "requirements.txt"
        if not req_file.exists():
            req_file.write_text(BACKEND_REQUIREMENTS, encoding="utf-8")
            generated_files.append("backend/requirements.txt")

        # Dockerfile
        dockerfile = backend_dir / "Dockerfile"
        if not dockerfile.exists():
            dockerfile.write_text(BACKEND_DOCKERFILE, encoding="utf-8")
            generated_files.append("backend/Dockerfile")

        # app/__init__.py
        app_dir = backend_dir / "app"
        app_dir.mkdir(parents=True, exist_ok=True)
        init_file = app_dir / "__init__.py"
        if not init_file.exists():
            init_file.write_text(BACKEND_INIT_APP, encoding="utf-8")
            generated_files.append("backend/app/__init__.py")

        # routers/__init__.py
        routers_dir = app_dir / "routers"
        routers_dir.mkdir(parents=True, exist_ok=True)
        routers_init = routers_dir / "__init__.py"
        if not routers_init.exists():
            routers_init.write_text(BACKEND_INIT_ROUTERS, encoding="utf-8")
            generated_files.append("backend/app/routers/__init__.py")

        # models/__init__.py
        models_dir = app_dir / "models"
        models_dir.mkdir(parents=True, exist_ok=True)
        models_init = models_dir / "__init__.py"
        if not models_init.exists():
            models_init.write_text(BACKEND_INIT_MODELS, encoding="utf-8")
            generated_files.append("backend/app/models/__init__.py")

        # schemas/__init__.py
        schemas_dir = app_dir / "schemas"
        schemas_dir.mkdir(parents=True, exist_ok=True)
        schemas_init = schemas_dir / "__init__.py"
        if not schemas_init.exists():
            schemas_init.write_text(BACKEND_INIT_SCHEMAS, encoding="utf-8")
            generated_files.append("backend/app/schemas/__init__.py")

        # crud/__init__.py
        crud_dir = app_dir / "crud"
        crud_dir.mkdir(parents=True, exist_ok=True)
        crud_init = crud_dir / "__init__.py"
        if not crud_init.exists():
            crud_init.write_text(BACKEND_INIT_CRUD, encoding="utf-8")
            generated_files.append("backend/app/crud/__init__.py")

    if project_type in ("fullstack", "frontend"):
        # Frontend files
        frontend_dir = workspace_dir / "frontend"
        frontend_dir.mkdir(parents=True, exist_ok=True)

        src_dir = frontend_dir / "src"
        src_dir.mkdir(parents=True, exist_ok=True)

        # App.vue
        app_vue = src_dir / "App.vue"
        if not app_vue.exists():
            app_vue.write_text(FRONTEND_APP_VUE, encoding="utf-8")
            generated_files.append("frontend/src/App.vue")

        # main.ts
        main_ts = src_dir / "main.ts"
        if not main_ts.exists():
            main_ts.write_text(FRONTEND_MAIN_TS, encoding="utf-8")
            generated_files.append("frontend/src/main.ts")

        # router/index.ts
        router_dir = src_dir / "router"
        router_dir.mkdir(parents=True, exist_ok=True)
        router_index = router_dir / "index.ts"
        if not router_index.exists():
            router_index.write_text(FRONTEND_ROUTER_INDEX, encoding="utf-8")
            generated_files.append("frontend/src/router/index.ts")

        # vite.config.ts
        vite_config = frontend_dir / "vite.config.ts"
        if not vite_config.exists():
            vite_config.write_text(FRONTEND_VITE_CONFIG, encoding="utf-8")
            generated_files.append("frontend/vite.config.ts")

        # tsconfig.json
        tsconfig = frontend_dir / "tsconfig.json"
        if not tsconfig.exists():
            tsconfig.write_text(FRONTEND_TSCONFIG, encoding="utf-8")
            generated_files.append("frontend/tsconfig.json")

        # tsconfig.node.json
        tsconfig_node = frontend_dir / "tsconfig.node.json"
        if not tsconfig_node.exists():
            tsconfig_node.write_text(FRONTEND_TSCONFIG_NODE, encoding="utf-8")
            generated_files.append("frontend/tsconfig.node.json")

        # env.d.ts
        env_dts = src_dir / "env.d.ts"
        if not env_dts.exists():
            env_dts.write_text(FRONTEND_ENV_D_TS, encoding="utf-8")
            generated_files.append("frontend/src/env.d.ts")

        # views/HomeView.vue
        views_dir = src_dir / "views"
        views_dir.mkdir(parents=True, exist_ok=True)
        home_view = views_dir / "HomeView.vue"
        if not home_view.exists():
            home_view.write_text(FRONTEND_HOME_VIEW, encoding="utf-8")
            generated_files.append("frontend/src/views/HomeView.vue")

        # utils/auth.ts
        utils_dir = src_dir / "utils"
        utils_dir.mkdir(parents=True, exist_ok=True)
        auth_ts = utils_dir / "auth.ts"
        if not auth_ts.exists():
            auth_ts.write_text(FRONTEND_UTILS_AUTH, encoding="utf-8")
            generated_files.append("frontend/src/utils/auth.ts")

        # Dockerfile
        dockerfile = frontend_dir / "Dockerfile"
        if not dockerfile.exists():
            dockerfile.write_text(FRONTEND_DOCKERFILE, encoding="utf-8")
            generated_files.append("frontend/Dockerfile")

        # nginx.conf
        nginx_conf = frontend_dir / "nginx.conf"
        if not nginx_conf.exists():
            nginx_conf.write_text(FRONTEND_NGINX_CONF, encoding="utf-8")
            generated_files.append("frontend/nginx.conf")

        # package.json
        package_json = frontend_dir / "package.json"
        if not package_json.exists():
            package_json.write_text(FRONTEND_PACKAGE_JSON, encoding="utf-8")
            generated_files.append("frontend/package.json")

        # index.html
        index_html = frontend_dir / "index.html"
        if not index_html.exists():
            index_html.write_text(FRONTEND_INDEX_HTML, encoding="utf-8")
            generated_files.append("frontend/index.html")

    if project_type == "fullstack":
        # Docker Compose
        docker_compose = workspace_dir / "docker-compose.yml"
        if not docker_compose.exists():
            docker_compose.write_text(DOCKER_COMPOSE, encoding="utf-8")
            generated_files.append("docker-compose.yml")

    # Initialize project memory with base technology decisions
    initialize_project_memory(workspace_dir, project_type)

    return generated_files


def initialize_project_memory(
    workspace_dir: Path,
    project_type: str = "fullstack",
    project_id: str = "default",
) -> ProjectMemory:
    """Initialize an empty project memory for agents to populate.

    This function creates an empty project memory file. Agents will record
    their own technology decisions and other important information during
    execution. The memory ensures consistency across multiple rounds.

    Args:
        workspace_dir: Target workspace directory.
        project_type: Type of project (fullstack, frontend, backend).
        project_id: Unique project identifier.

    Returns:
        ProjectMemory: Empty project memory instance ready for agents to use.
    """
    memory = ProjectMemory(project_id=project_id, workspace_dir=workspace_dir)

    # Clear existing memory for fresh start
    memory.clear()

    # Only record the project type as a basic constraint
    # All technology decisions will be made by agents
    memory.record_decision(
        category=DecisionCategory.CONSTRAINT,
        key="project_type",
        value=project_type,
        description=f"项目类型: {project_type}",
        made_by="scaffold",
        round_index=0,
    )

    return memory


def finalize_project(
    workspace_dir: Path,
    deliverables_dir: Path,
) -> dict[str, Any]:
    """Finalize project by merging files and validating completeness.

    Args:
        workspace_dir: Workspace directory with generated code
        deliverables_dir: Directory containing project JSON files

    Returns:
        dict: Finalization report with merged files and validation results
    """
    report: dict[str, Any] = {
        "merged_files": [],
        "copied_files": [],
        "conflicts": [],
        "file_errors": [],  # Collect file operation errors for LLM analysis
        "validation": {"passed": True, "missing": [], "errors": []},
    }

    # Collect all files from project JSONs
    all_files: dict[str, list[dict[str, Any]]] = {}
    project_files = list(deliverables_dir.glob("REQ-*_project.json"))

    for pf in project_files:
        try:
            with open(pf, encoding="utf-8") as f:
                data = json.load(f)
            for file_info in data.get("files", []):
                path = file_info.get("path", "")
                content = file_info.get("content", "")
                if path and content:
                    if path not in all_files:
                        all_files[path] = []
                    all_files[path].append({
                        "source": pf.name,
                        "content": content,
                    })
        except Exception as e:
            report["validation"]["errors"].append(f"Failed to parse {pf.name}: {e}")

    # Process files - copy or merge
    for file_path, versions in all_files.items():
        full_path = workspace_dir / file_path

        try:
            # Check if path is a directory (conflict)
            if full_path.exists() and full_path.is_dir():
                report["file_errors"].append({
                    "path": file_path,
                    "error": "Path exists as directory",
                    "type": "is_directory",
                    "suggestion": "Skip or rename file",
                })
                continue

            full_path.parent.mkdir(parents=True, exist_ok=True)

            if len(versions) == 1:
                # Single version - just copy
                full_path.write_text(versions[0]["content"], encoding="utf-8")
                report["copied_files"].append(file_path)
            else:
                # Multiple versions - need to merge or pick best
                # For now, use the longest version (most complete)
                best_version = max(versions, key=lambda v: len(v["content"]))
                full_path.write_text(best_version["content"], encoding="utf-8")
                report["merged_files"].append({
                    "path": file_path,
                    "sources": [v["source"] for v in versions],
                    "selected": best_version["source"],
                })
                report["conflicts"].append({
                    "path": file_path,
                    "versions": len(versions),
                })

        except IsADirectoryError:
            report["file_errors"].append({
                "path": file_path,
                "error": "Cannot write to directory path",
                "type": "is_directory",
                "suggestion": "Skip or rename file",
            })
        except PermissionError as e:
            report["file_errors"].append({
                "path": file_path,
                "error": f"Permission denied: {e}",
                "type": "permission",
                "suggestion": "Check file permissions",
            })
        except Exception as e:
            report["file_errors"].append({
                "path": file_path,
                "error": str(e),
                "type": "unknown",
                "suggestion": "Review error and retry",
            })

    # Fix frontend import issues
    fix_report = fix_frontend_imports(workspace_dir)
    report["import_fixes"] = fix_report

    # Validate project completeness
    validation = validate_project_completeness(workspace_dir)
    report["validation"].update(validation)

    return report


def fix_frontend_imports(workspace_dir: Path) -> dict[str, Any]:
    """Fix common import issues in frontend code.

    This function scans Vue/TS/JS files and fixes:
    - Removes imports of incompatible libraries (vuex, vuetify)
    - Fixes import paths to match actual file structure
    - Updates package.json with missing dependencies

    Args:
        workspace_dir: Workspace directory to fix

    Returns:
        dict: Report of fixes made
    """
    import re

    report: dict[str, Any] = {
        "files_fixed": [],
        "imports_removed": [],
        "dependencies_added": [],
    }

    frontend_src = workspace_dir / "frontend/src"
    if not frontend_src.exists():
        return report

    # Patterns to remove (incompatible with Element Plus + Pinia stack)
    incompatible_imports = [
        (r"import\s+.*\s+from\s+['\"]vuex['\"].*\n?", "vuex"),
        (r"import\s+.*\s+from\s+['\"]vuetify['\"].*\n?", "vuetify"),
        (r"import\s+\{[^}]*useDisplay[^}]*\}\s+from\s+['\"]vuetify['\"].*\n?", "vuetify"),
        (r"import\s+\{[^}]*useStore[^}]*\}\s+from\s+['\"]vuex['\"].*\n?", "vuex"),
    ]

    # Scan and fix files
    for ext in ["*.vue", "*.ts", "*.js"]:
        for file_path in frontend_src.rglob(ext):
            try:
                content = file_path.read_text(encoding="utf-8")
                original_content = content
                file_fixed = False

                for pattern, lib_name in incompatible_imports:
                    if re.search(pattern, content):
                        content = re.sub(pattern, "", content)
                        report["imports_removed"].append({
                            "file": str(file_path.relative_to(workspace_dir)),
                            "library": lib_name,
                        })
                        file_fixed = True

                # Remove unused variables from removed imports
                # e.g., "const { mobile } = useDisplay()" when useDisplay is removed
                unused_patterns = [
                    r"const\s+\{[^}]*\}\s*=\s*useDisplay\(\)\s*\n?",
                    r"const\s+\w+\s*=\s*useStore\(\)\s*\n?",
                ]
                for pattern in unused_patterns:
                    if re.search(pattern, content):
                        content = re.sub(pattern, "", content)
                        file_fixed = True

                if file_fixed and content != original_content:
                    file_path.write_text(content, encoding="utf-8")
                    report["files_fixed"].append(
                        str(file_path.relative_to(workspace_dir))
                    )

            except Exception:
                pass  # Skip files that can't be processed

    # Ensure package.json has required dependencies
    package_json_path = workspace_dir / "frontend/package.json"
    if package_json_path.exists():
        try:
            package_data = json.loads(package_json_path.read_text(encoding="utf-8"))
            deps = package_data.get("dependencies", {})

            required_deps = {
                "chart.js": "^4.4.0",
                "@vueuse/core": "^10.7.0",
            }

            for dep, version in required_deps.items():
                if dep not in deps:
                    deps[dep] = version
                    report["dependencies_added"].append(dep)

            if report["dependencies_added"]:
                package_data["dependencies"] = deps
                package_json_path.write_text(
                    json.dumps(package_data, indent=2, ensure_ascii=False),
                    encoding="utf-8",
                )

        except Exception:
            pass

    return report


def validate_project_completeness(workspace_dir: Path) -> dict[str, Any]:
    """Validate that project has all required files.

    Args:
        workspace_dir: Workspace directory to validate

    Returns:
        dict: Validation results
    """
    result: dict[str, Any] = {
        "passed": True,
        "missing": [],
        "warnings": [],
    }

    # Required backend files
    backend_required = [
        "backend/requirements.txt",
        "backend/app/__init__.py",
        "backend/app/main.py",
        "backend/app/database.py",
    ]

    # Required frontend files
    frontend_required = [
        "frontend/package.json",
        "frontend/index.html",
        "frontend/src/App.vue",
        "frontend/src/main.ts",
        "frontend/vite.config.ts",
    ]

    # Check backend
    for req_file in backend_required:
        if not (workspace_dir / req_file).exists():
            result["missing"].append(req_file)
            result["passed"] = False

    # Check frontend
    for req_file in frontend_required:
        if not (workspace_dir / req_file).exists():
            result["missing"].append(req_file)
            result["passed"] = False

    # Check for common issues
    # 1. Check if router has routes
    router_files = list((workspace_dir / "frontend/src/router").glob("*.ts")) + \
                   list((workspace_dir / "frontend/src/router").glob("*.js"))
    if not router_files:
        result["warnings"].append("No router configuration found")

    # 2. Check if there are any views
    views_dir = workspace_dir / "frontend/src/views"
    if views_dir.exists():
        vue_files = list(views_dir.glob("*.vue"))
        if len(vue_files) < 2:
            result["warnings"].append(f"Only {len(vue_files)} view components found")

    return result


__all__ = [
    "generate_project_scaffolding",
    "finalize_project",
    "validate_project_completeness",
    "initialize_project_memory",
]
